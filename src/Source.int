/***
 -------------------------------------------------------------------------------
 |                                                                             |
 | NASA Glenn Research Center                                                  |
 | 21000 Brookpark Rd 		                                                     |
 | Cleveland, OH 44135 	                                                       |
 |                                                                             |
 | File Name:     Source.int										                               |
 | Author(s):     George Thomas, Jeffrey Csank, David Sadey, Tom Lavelle       |
 | Date(s):       December 2019                                                |
 |                                                                             |
 -------------------------------------------------------------------------------
***/

#ifndef __SOURCE__
#define __SOURCE__

int ESO_Id_ExceededEnergyDes = (10000 * 145) + (100 * 22) + 1;
ESOregCreate(ESO_Id_ExceededEnergyDes, 1, "Energy Constraint Exceeded");

class Source extends ElectricElement {
  
  //----------------------------
  // ****** DOCUMENTATION ******
  //----------------------------
  
  // title = "";

  description = "The " + isA() + " serves as a voltage source with constant 
  impedance. It also contains simplified logic for calculating energy consumed 
  to be used with a MDP solver setup. This energy is used to compute mass via a 
  flat assumption for specific energy. Users can also specify specific power. 
  Mass is calculated as the larger of the two masses (design power/spc power) 
  and (design energy/spc energy)";
  
  // usageNotes = isA() + "- NOTE TO USERS: This file....";
  // background = "";
  
  //------------------------------
  // ****** SETUP VARIABLES ******
  //------------------------------
  
  real pfDes {
    value = 0; IOstatus = "output"; units = "kW"; // [kilowatts]
    description = "Design power factor at output of this source element.";
  }

  real effDes {
    value = 0.95; IOstatus = "input"; units = "none";
    description = "Design efficiency of this source element.";
  }

  real pf {
    value = 0; IOstatus = "output"; units = "kW"; // [kilowatts]
    description = "Actual (calculated) power factor at output of this source element.";
  }

  eff {
    value = 0.95; IOstatus = "output"; units = "none";
    description = "Actual (calculated) efficiency of this source element.";
  }

  real R {
    value = .01;  IOstatus = "output";  units = "ohm";
  }

  real L {
    value = .0000796;  IOstatus = "output";  units = "H"; // [henrys]
  }

  real frequency {
    value = 0; IOstatus = "input"; units = "Hz"; // [hertz]
    description = "Output frequency";
  }

  Loss_r {
    value = 0; IOstatus = "output"; units = "kW"; // [kilowatts]
    description = "Real component of losses in this load.";
  }

  Loss_j {
    value = 0; IOstatus = "output"; units = "kW"; // [kilowatts]
    description = "Imaginary component of losses in this load.";
  }

  real Q_heat {
    value = 0; IOstatus = "output"; units = "Btu/sec"; // [BTUs / sec]
    description = "Power dissipation in BTU/s at current time.";
  }

  real energyDes {
    value = 0; IOstatus = "output"; units = "none"; // [kW-h]
    description = "Design energy for this source.";
  }

  real energyConsumed {
    value = 0; IOstatus = "output"; units = "none"; // [kW-h]
    description = "Total energy consumed over mission, only use off-design.";
  }

  real energy {
    value = 0; IOstatus = "output"; units = "none"; // [kW-h]
    description = "Energy consumed at the current operating point.";
  }

  real segmentTime {
    value = 0.25; IOstatus = "output"; units = "hr"; // [h]
    description = "Hours spent running at the current operating point.";
  }

  real Vreal {
    value = 1000.;  IOstatus = "output";  units = "V"; // [volts]
    description = "Real portion of output voltage.";
  }

  real Vimag {
    value = -1.;  IOstatus = "output";  units = "V"; // [volts]
    description = "Imaginary portion of output voltage.";
  }
  
  real SpecificPower {
    value = 13; IOstatus = "input"; units = "none"; // [kW/kg]
    description = "Power to weight ratio for the source.";
  }
  
  real SpecificEnergy {
    value = 130; IOstatus = "input"; units = "none"; // [W-h/kg]
    description = "Energy to weight ratio for the source.";
  }

  Mass {
    value = 1.; IOstatus = "output"; units = "kg"; // [kilograms]
    description = "Computed on-design mass for the source.";
  }

  //------------------------------------
  // ****** OPTION VARIABLE SETUP ******
  //------------------------------------

  Option switchDes {
    allowedValues = { "DESIGN", "OFFDESIGN" }
    description = "Determines if the element is in design or off-design mode.";
    rewritableValues = FALSE;
    trigger = TRUE;
  }

  Option switchThermPort {
    allowedValues = { "TRUE", "FALSE" }
    description = "Determines if component needs thermal port.";
    rewritableValues = FALSE;  // enables converter optimization
    trigger = TRUE;
  }

  Option switchTrackEnergy {
    allowedValues = { "FALSE", "TRUE" }
    description = "Determines if we should track energy or not when running off-design.";
    rewritableValues = FALSE;  // enables converter optimization
  }

  Option multiDes {
    allowedValues = { "FALSE", "TRUE" }
    description = "Determines if component is undergoing multi-design point simulation.";
    rewritableValues = FALSE;
    trigger = TRUE;
  }
  
  //----------------------------------------------------------
  // ****** SETUP PORTS, FLOW STATIONS, SOCKETS, TABLES ******
  //----------------------------------------------------------  
  
  /* ELECTRICAL PORTS */

  ElectricOutputPort EP_O {
    description = "Electric output port.";
  }

  /* SOCKETS */

  Socket S_eThermMass {
    allowedValues = { "Q_heat", "Mass" }
    description = "Thermal mass socket.";
    socketType = "EThermalMass";
  }
  
  //-----------------------------------------------------
  // ******  ADD SOLVER INDEPENDENTS & DEPENDENTS  ******
  //-----------------------------------------------------

  // MDP variable
  Independent ind_energyDes {
    varName = "energyDes";
    description = "Varies design energy to match calculated energy at design condition.";
  }

  // MDP variable
  Dependent dep_energyDes {
    eq_lhs = "energyDes";
    eq_rhs = "energy";
  }
  
  //-------------------------------------------
  // ****** VARIABLE CHANGED METHODOLOGY ******
  //-------------------------------------------

  void variableChanged(string name, any oldVal) {
    if (name == "switchThermPort") {
       if (switchThermPort == "TRUE") {
           create("", "ThermalInputPort", "Q_I");
       }
    }

    if (name == "multiDes") {
      if (switchDes == DESIGN) {
        ind_energyDes.autoSetup = TRUE;
        dep_energyDes.autoSetup = TRUE;
      }
    }
  }

  //-----------------------------------------------
  // ****** PERFORM ENGINEERING CALCULATIONS ******
  //-----------------------------------------------
  
  /** So this component expects you to set Vreal, Vimag, and effDes. It will
   * calculate (resistive only) impedance, power factor, etc.
   */
  void calculate() {
    
    /** 
     * If we're on-design, we need to figure out the output impedance based
     * on the design efficiency. Otherwise, calculate the loss and the 
     * efficiency based on the impedance (which is held constant).
     */

    pf = cos(EP_O.S.phase);

    if (switchDes == "DESIGN") {
      pfDes = pf;
      eff = effDes;
      
      // internal power, before flowing through this component's output impedance
      real PInternal = EP_O.S.r / eff;
      Loss_r = PInternal - EP_O.S.r;
      Loss_j = 0;
      R = Loss_r / EP_O.I.mag**2;
      L = 0;

      // Energy consumed at this operating point.
      energy = PInternal * segmentTime;

      // get design values 
      if (multiDes != "TRUE") {
        energyDes = energy;
      }

      real energyBasedMass = (energyDes/1000) / SpecificEnergy; // (kW-h/1000) / (W-h/kg) = kg
      real powerBasedMass = EP_O.S.r / SpecificPower;

      if (energyBasedMass > powerBasedMass) {
        Mass = energyBasedMass; // compute mass based on assumed specific energy
      } else {
        Mass = powerBasedMass; // compute mass based on assumed specific power
      }
    } else {
      Loss_r = EP_O.I.mag**2 * R;
      Loss_j = 0;
      eff = EP_O.S.r / (EP_O.S.r + Loss_r);
      
      // energy consumed at this operating point.
      energy = (EP_O.S.r + Loss_r) * segmentTime;
    }

    if (switchThermPort == "TRUE") {
      real KW_PER_BTU_PER_SEC = 1.05505585;
      Q_heat = sqrt(Loss_r**2 + Loss_j**2);
      Q_heat /= KW_PER_BTU_PER_SEC;

      // run the thermal mass model.
      if (!S_eThermMass.isEmpty()) {
        S_eThermMass.execute();
      }
    }
  }

  void prePass() {
    EP_O.frequency = frequency;
    EP_O.setIVRMS(EP_O.I.r, EP_O.I.j, Vreal, Vimag);
  }

  void trackEnergy() {
    Source.energyConsumed += Source.energy;
    if (Source.energyConsumed > Source.energyDes) {
      ESOreport(ESO_Id_ExceededEnergyDes,
      "Source component's energy consumed (" + toStr(Source.energyConsumed) +
      ") exceeded design energy (" + toStr(Source.energyDes)+").", 1);
    }
  }
}
#endif
