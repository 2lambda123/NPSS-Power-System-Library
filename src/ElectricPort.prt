/***
 -------------------------------------------------------------------------------
 |                                                                             |
 | NASA Glenn Research Center                                                  |
 | 21000 Brookpark Rd 		                                                     |
 | Cleveland, OH 44135 	                                                       |
 |                                                                             |
 | File Name:     ElectricPort.prt											                       |
 | Author(s):     Jeffrey Csank, David Sadey, Tom Lavelle                      |
 | Date(s):       December 2019                                                |
 |                                                                             |
 -------------------------------------------------------------------------------
***/

#ifndef __ELECTRIC_PORT__
#define __ELECTRIC_PORT__

#include "ComplexNumber.int"

int ESO_Id_NoRefPort = (10000 * 141) + (100 * 22) + 1;
ESOregCreate(ESO_Id_NoRefPort, 1, "No refport in this port (make sure the port is connected)!");
int ESO_Id_ImagInDC = (10000 * 142) + (100 * 22) + 1;
ESOregCreate(ESO_Id_ImagInDC, 1, "Imaginary components in DC port!");

class ElectricPort extends Subelement {
  
  //------------------------------
  // ****** DOCUMENTATION ********
  //------------------------------  

  // title = "";
  // description = "The " + isA() + "";
  // usageNotes = isA() + "- NOTE TO USERS: This file....";
  // background = "";
  
  //--------------------------------
  // ****** SETUP VARIABLES ********
  //--------------------------------

  string converterComponenets[] = { "Inverter", "Rectifier", "DC_DC_Converter" };
  string singlePortComponents[] = { "Generator", "Motor", "Source", "ConstantPowerLoad" };

  ComplexNumber V {
    lock = TRUE;	
  }

  ComplexNumber I {
    lock = FALSE;	
  }

  ComplexNumber S {
    lock = TRUE;
  }
  
  V.hide(1);
  S.hide(1);
  I.hide(1);
  
  socketRequired = 0;
  
  Option ElectricPowerType {
    allowedValues = { "AC1", "DC", "AC3" };
    description = "Electric power type (DC, AC1, AC3).";
    trigger = 1;
    rewritableValues = TRUE;
  }
  
  real frequency {
    value = 0.; 
    IOstatus = "input";
    description = "Frequency of AC current through port.";
  }
  
  real PF {
    value = 0;
    description = "Ratio of real to apparent power.";
  }
  
  string refport {
    description = "Port used to copy from.";	
  }
  
  ComplexNumber VLN {
    hide(0);	
  }
  
  //---------------------------------------------
  // ******* VARIABLE CHANGED METHODOLOGY *******
  //---------------------------------------------
  void variableChanged(string name, any oldVal) {

    // change variable IO status depending switchDes status
    if (name == "ElectricPowerType") {
      if (ElectricPowerType == "DC") {
        V.hide(0);
        S.hide(0);
        I.hide(0);
        frequency = 0;
      } else if (ElectricPowerType == "AC1") {
        V.hide(0);
        S.hide(0);
        I.hide(0);		
      } else if (ElectricPowerType == "AC3") {
        V.hide(0);
        S.hide(0);
        I.hide(0);		
      } 
    } 
  } 
  
  // copy the port information
  void copyport() {
    V.copy(refport+".V");
    I.copy(refport+".I");
    S.copy(refport+".S");
    VLN.copy(refport+".VLN");
    
    if (refport->frequency == 0) {
      refport->frequency = frequency;
    } else {
      frequency = refport->frequency;
    }

    if (refport == "") {
      ESOreport(ESO_Id_NoRefPort, "Ref port empty!");
    }		
  }
  
  //------------------------------------------------------
  // push the port information
  //------------------------------------------------------
  void pushport() {
    if (refport == "") {
      ESOreport(ESO_Id_NoRefPort, "Ref port empty!");
    } else {
      refport->copyport();
    }
  }
  
  //-----------------------------------------------------------
  // set the port conditions based on current, voltage, 
  // and angles in degrees
  //-----------------------------------------------------------
  void setIVRMSphaseDeg(real ImagRMS, real Iangle, real VmagRMS, real Vangle) {
    setIVRMS(ImagRMS * cos(Iangle * PI/180.), ImagRMS * sin(Iangle * PI/180.),
             VmagRMS * cos(Vangle * PI/180.), VmagRMS * sin(Vangle * PI/180.));
  }
  
  // set the port conditions based on current, voltage, and angles in radians
  void setIVRMSphaseRad(real ImagRMS, real Iangle, real VmagRMS, real Vangle) {
    setIVRMS(ImagRMS * cos(Iangle), ImagRMS * sin(Iangle),
             VmagRMS * cos(Vangle), ImagRMS * sin(Vangle));
  }
  
  // set the port conditions based on complex current and voltage
  void setIVRMS(real IrRMS, real IjRMS, real VrRMS, real VjRMS) {
    
    // unlock the parameters so they can be set
    V.lock = FALSE;
    I.lock = FALSE;
    S.lock = FALSE;
    
    // set the current and voltage
    V.setrjRMS(VrRMS, VjRMS);
    I.setrjRMS(IrRMS, IjRMS);
    
    // check to see if we are in DC power mode and passing imaginary info
    if (ElectricPowerType == "DC") {	
      if (VjRMS != 0. || IjRMS != 0.) {
        ESOreport(ESO_Id_ImagInDC, refport + " contains imaginary components!", 1);
      }
    }
    
    // determine the power
    if (ElectricPowerType == "DC" || ElectricPowerType == "AC1") {

      // VLN = V (VLL) for single phase AC
      VLN.copy("V");
      
      // calculate power
      S.copy("I");
      S.conjugate();
      S.times("V");
      S.scale(1. / 1000.);
    } else if (ElectricPowerType == "AC3") {
      
      // calculate VLN
      VLN.copy("V");
      VLN.setMagPhase( V.mag, V.phase - (30. * PI/180.));
      VLN.scale(sqrt(1. / 3.));

      // calculate power based off VLN (since VLN is already scaled)
      S.copy("I");
      S.conjugate();
      S.timesRMS("VLN");
      S.scale(3. / 1000.);
    }
    
    // calculate power factor
    PF = S.r / S.mag;
    
    // lock the numbers again
    // only way to set the values should be through this function
    V.lock = TRUE;
    I.lock = FALSE;
    S.lock = TRUE;
    
    pushport();	
  }


  // sets component power type the same on both input and output ports
  void getOtherPort(string port) {
    if (port->isA() == "ElectricInputPort") {
      nextPort = port->parent.EP_O.getPathName();
    } else {
      nextPort = port->parent.EP_I.getPathName();
    }
  }

  // depth-first traversal of circuit graph to populate port power type
  void propagatePower() {

    string nextPort = propagate(refport);

    if (nextPort != "complete") {
      propagateNode(nextPort);
    }
  }

  string propagate(string originPort) {

    string port = originPort;
    string powerType = port->ElectricPowerType
    string portComponent;

    while (!singlePortComponents.contains(port->isA())) {

      portComponent = port->parent.isA();
      cout << "Current Port: " << port;

      if (portComponent != "Enode") { // check if port is a node
        if (!converterComponenets.contains(portComponent)) { // ignore conversion ports
          port->setOption("ElectricPowerType", powerType)
          port = getOtherPort(port);
          port->setOption("ElectricPowerType", powerType);
        } else {
          port = getOtherPort();
          powerType = port->ElectricPowerType;
        }
        port = port->refport;
      } else {
        return port;
      }
    }
    return "complete";
  }
  
  void propagateNode() {

  }
}

class ElectricInputPort extends ElectricPort;
class ElectricOutputPort extends ElectricPort;

#endif